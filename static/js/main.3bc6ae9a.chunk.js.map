{"version":3,"sources":["actions/index.js","utils/index.js","reducers/game_reducer.js","reducers/index.js","components/grid-square.js","components/grid-board.js","components/next-block.js","components/score-board.js","components/controls.js","components/message-popup.js","App.js","index.js"],"names":["moveRight","type","moveLeft","rotate","moveDown","pause","resume","restart","gridDefault","array","row","push","col","shapes","nextRotation","shape","rotation","length","canMoveTo","grid","x","y","currentShape","proposedX","proposedY","possibleRow","undefined","randomShape","min","max","Math","floor","random","defaultState","nextShape","isRunning","score","speed","gameOver","addBlockToGrid","blockOffGrid","block","newGrid","checkRows","completedRows","indexOf","splice","unshift","Array","fill","gameReducer","state","action","newRotation","maybeY","obj","newState","reducers","combineReducers","game","GridSquare","classes","this","props","color","className","Component","GridBoard","lastUpdateTime","progressTime","blockColor","map","rowArray","square","blockX","blockY","k","key","time","window","requestAnimationFrame","update","bind","deltaTime","makeGrid","connect","NextBlock","ScoreBoard","onClick","e","Controls","console","log","MessagePopup","message","isHidden","store","createStore","App","ReactDOM","render","StrictMode","document","getElementById"],"mappings":"2SASaA,EAAY,WACrB,MAAO,CAAEC,KAPa,eAUXC,EAAW,WACtB,MAAO,CAAED,KAZa,cAeXE,EAAS,WACpB,MAAO,CAAEF,KAda,WAiBXG,EAAW,WACtB,MAAO,CAAEH,KAjBa,cAoBXI,EAAQ,WACnB,MAAO,CAAEJ,KA1Ba,UA6BXK,EAAS,WACpB,MAAO,CAAEL,KA7Ba,WAgCXM,EAAU,WACrB,MAAO,CAAEN,KA3Ba,Y,QCFbO,EAAc,WAKvB,IAJA,IAEMC,EAAQ,GAELC,EAAM,EAAGA,EAJL,GAIiBA,IAAO,CACjCD,EAAME,KAAK,IACX,IAAK,IAAIC,EAAM,EAAGA,EALT,GAKqBA,IAC5BH,EAAMC,GAAKC,KAAK,GAGtB,OAAOF,GAIEI,EAAS,CAElB,CAAC,CAAC,CAAC,EAAE,EAAE,EAAE,GACP,CAAC,EAAE,EAAE,EAAE,GACP,CAAC,EAAE,EAAE,EAAE,GACP,CAAC,EAAE,EAAE,EAAE,KAGT,CAAC,CAAC,CAAC,EAAE,EAAE,EAAE,GACP,CAAC,EAAE,EAAE,EAAE,GACP,CAAC,EAAE,EAAE,EAAE,GACP,CAAC,EAAE,EAAE,EAAE,IAER,CAAC,CAAC,EAAE,EAAE,EAAE,GACP,CAAC,EAAE,EAAE,EAAE,GACP,CAAC,EAAE,EAAE,EAAE,GACP,CAAC,EAAE,EAAE,EAAE,KAGT,CAAC,CAAC,CAAC,EAAE,EAAE,EAAE,GACP,CAAC,EAAE,EAAE,EAAE,GACP,CAAC,EAAE,EAAE,EAAE,GACP,CAAC,EAAE,EAAE,EAAE,IAER,CAAC,CAAC,EAAE,EAAE,EAAE,GACP,CAAC,EAAE,EAAE,EAAE,GACP,CAAC,EAAE,EAAE,EAAE,GACP,CAAC,EAAE,EAAE,EAAE,IAER,CAAC,CAAC,EAAE,EAAE,EAAE,GACP,CAAC,EAAE,EAAE,EAAE,GACP,CAAC,EAAE,EAAE,EAAE,GACP,CAAC,EAAE,EAAE,EAAE,IAER,CAAC,CAAC,EAAE,EAAE,EAAE,GACP,CAAC,EAAE,EAAE,EAAE,GACP,CAAC,EAAE,EAAE,EAAE,GACP,CAAC,EAAE,EAAE,EAAE,KAGT,CAAC,CAAC,CAAC,EAAE,EAAE,EAAE,GACP,CAAC,EAAE,EAAE,EAAE,GACP,CAAC,EAAE,EAAE,EAAE,GACP,CAAC,EAAE,EAAE,EAAE,IAER,CAAC,CAAC,EAAE,EAAE,EAAE,GACP,CAAC,EAAE,EAAE,EAAE,GACP,CAAC,EAAE,EAAE,EAAE,GACP,CAAC,EAAE,EAAE,EAAE,IAER,CAAC,CAAC,EAAE,EAAE,EAAE,GACP,CAAC,EAAE,EAAE,EAAE,GACP,CAAC,EAAE,EAAE,EAAE,GACP,CAAC,EAAE,EAAE,EAAE,IAER,CAAC,CAAC,EAAE,EAAE,EAAE,GACP,CAAC,EAAE,EAAE,EAAE,GACP,CAAC,EAAE,EAAE,EAAE,GACP,CAAC,EAAE,EAAE,EAAE,KAGT,CAAC,CAAC,CAAC,EAAE,EAAE,EAAE,GACP,CAAC,EAAE,EAAE,EAAE,GACP,CAAC,EAAE,EAAE,EAAE,GACP,CAAC,EAAE,EAAE,EAAE,IAER,CAAC,CAAC,EAAE,EAAE,EAAE,GACP,CAAC,EAAE,EAAE,EAAE,GACP,CAAC,EAAE,EAAE,EAAE,GACP,CAAC,EAAE,EAAE,EAAE,IAER,CAAC,CAAC,EAAE,EAAE,EAAE,GACP,CAAC,EAAE,EAAE,EAAE,GACP,CAAC,EAAE,EAAE,EAAE,GACP,CAAC,EAAE,EAAE,EAAE,IAER,CAAC,CAAC,EAAE,EAAE,EAAE,GACP,CAAC,EAAE,EAAE,EAAE,GACP,CAAC,EAAE,EAAE,EAAE,GACP,CAAC,EAAE,EAAE,EAAE,KAGT,CAAC,CAAC,CAAC,EAAE,EAAE,EAAE,GACP,CAAC,EAAE,EAAE,EAAE,GACP,CAAC,EAAE,EAAE,EAAE,GACP,CAAC,EAAE,EAAE,EAAE,IAER,CAAC,CAAC,EAAE,EAAE,EAAE,GACP,CAAC,EAAE,EAAE,EAAE,GACP,CAAC,EAAE,EAAE,EAAE,GACP,CAAC,EAAE,EAAE,EAAE,KAGT,CAAC,CAAC,CAAC,EAAE,EAAE,EAAE,GACP,CAAC,EAAE,EAAE,EAAE,GACP,CAAC,EAAE,EAAE,EAAE,GACP,CAAC,EAAE,EAAE,EAAE,IAER,CAAC,CAAC,EAAE,EAAE,EAAE,GACP,CAAC,EAAE,EAAE,EAAE,GACP,C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","file":"static/js/main.3bc6ae9a.chunk.js","sourcesContent":["export const PAUSE      = \"PAUSE\"       // Pause the game\nexport const RESUME     = \"RESUME\"      // Resume a paused game\nexport const MOVE_LEFT  = \"MOVE_LEFT\"   // Move piece left\nexport const MOVE_RIGHT = \"MOVE_RIGHT\"  // Move piece right\nexport const ROTATE     = \"ROTATE\"      // Rotate piece\nexport const MOVE_DOWN  = \"MOVE_DOWN\"   // Move piece down\nexport const GAME_OVER  = \"GAME_OVER\"   // The game is over\nexport const RESTART    = \"RESTART\"     // Restart Game\n\nexport const moveRight = () => {\n    return { type: MOVE_RIGHT }\n  }\n  \n  export const moveLeft = () => {\n    return { type: MOVE_LEFT }\n  }\n  \n  export const rotate = () => {\n    return { type: ROTATE }\n  }\n  \n  export const moveDown = () => {\n    return { type: MOVE_DOWN }\n  }\n  \n  export const pause = () => {\n    return { type: PAUSE }\n  }\n  \n  export const resume = () => {\n    return { type: RESUME }\n  }\n  \n  export const restart = () => {\n    return { type: RESTART }\n  }\n","export const random = (min, max) => {\n    return Math.floor(Math.random() * (max - min + 1)) + min\n  }\n\n// Returns the default grid\nexport const gridDefault = () => {\n    const rows = 18\n    const cols = 10\n    const array = []\n  \n    for (let row = 0; row < rows; row++) {\n        array.push([])\n        for (let col = 0; col < cols; col++) {\n          array[row].push(0)\n        }\n    }\n    return array\n  }\n\n  // Define block shapes and their rotations as arrays.\nexport const shapes = [\n    // none\n    [[[0,0,0,0],\n      [0,0,0,0],\n      [0,0,0,0],\n      [0,0,0,0]]],\n  \n    // I\n    [[[0,0,0,0],\n      [1,1,1,1],\n      [0,0,0,0],\n      [0,0,0,0]],\n  \n     [[0,1,0,0],\n      [0,1,0,0],\n      [0,1,0,0],\n      [0,1,0,0]]],\n  \n    // T\n    [[[0,0,0,0],\n      [1,1,1,0],\n      [0,1,0,0],\n      [0,0,0,0]],\n  \n     [[0,1,0,0],\n      [1,1,0,0],\n      [0,1,0,0],\n      [0,0,0,0]],\n  \n     [[0,1,0,0],\n      [1,1,1,0],\n      [0,0,0,0],\n      [0,0,0,0]],\n  \n     [[0,1,0,0],\n      [0,1,1,0],\n      [0,1,0,0],\n      [0,0,0,0]]],\n  \n    // L\n    [[[0,0,0,0],\n      [1,1,1,0],\n      [1,0,0,0],\n      [0,0,0,0]],\n  \n     [[1,1,0,0],\n      [0,1,0,0],\n      [0,1,0,0],\n      [0,0,0,0]],\n  \n     [[0,0,1,0],\n      [1,1,1,0],\n      [0,0,0,0],\n      [0,0,0,0]],\n  \n     [[0,1,0,0],\n      [0,1,0,0],\n      [0,1,1,0],\n      [0,0,0,0]]],\n  \n    // J\n    [[[1,0,0,0],\n      [1,1,1,0],\n      [0,0,0,0],\n      [0,0,0,0]],\n  \n     [[0,1,1,0],\n      [0,1,0,0],\n      [0,1,0,0],\n      [0,0,0,0]],\n  \n     [[0,0,0,0],\n      [1,1,1,0],\n      [0,0,1,0],\n      [0,0,0,0]],\n  \n     [[0,1,0,0],\n      [0,1,0,0],\n      [1,1,0,0],\n      [0,0,0,0]]],\n  \n    // Z\n    [[[0,0,0,0],\n      [1,1,0,0],\n      [0,1,1,0],\n      [0,0,0,0]],\n  \n     [[0,0,1,0],\n      [0,1,1,0],\n      [0,1,0,0],\n      [0,0,0,0]]],\n  \n    // S\n    [[[0,0,0,0],\n      [0,1,1,0],\n      [1,1,0,0],\n      [0,0,0,0]],\n  \n     [[0,1,0,0],\n      [0,1,1,0],\n      [0,0,1,0],\n      [0,0,0,0]]],\n  \n    // O\n    [[[0,1,1,0],\n      [0,1,1,0],\n      [0,0,0,0],\n      [0,0,0,0]]]\n  ]\n\n// Returns the next rotation for a shape\n// rotation can't exceed the last index of the the rotations for the given shape.\nexport const nextRotation = (shape, rotation) => {\n  return (rotation + 1) % shapes[shape].length\n}\n\nexport const canMoveTo = (shape, grid, x, y, rotation) => {\n  const currentShape = shapes[shape][rotation]\n  // Loop through all rows and cols of the **shape**\n  for (let row = 0; row < currentShape.length; row++) {\n      for (let col = 0; col < currentShape[row].length; col++) {\n          // Look for a 1 here\n          if (currentShape[row][col] !== 0) {\n              // x offset on grid\n              const proposedX = col + x\n              // y offset on grid\n              const proposedY = row + y\n              if (proposedY < 0) {\n                  continue\n              }\n              // Get the row on the grid\n              const possibleRow = grid[proposedY]\n              // Check row exists\n              if (possibleRow) {\n                  // Check if this column in the row is undefined, if it's off the edges, 0, and empty\n                  if (possibleRow[proposedX] === undefined || possibleRow[proposedX] !== 0) {\n                      // undefined or not 0 and it's occupied we can't move here.\n                      return false\n                  }\n              } else {\n                  return false\n              }\n          }\n      }\n  }\n  return true\n}\n  // Return the index of a random shape from 1 to the number of items in `shapes`\n// We don't want the first item, which is an empty shape\nexport const randomShape = () => {\n    return random(1, shapes.length - 1)\n  }\n\n// Return the default state for the game\nexport const defaultState = () => {\n    return {\n      // Create an empty grid\n      grid: gridDefault(),\n      // Get a new random shape\n      shape: randomShape(),\n      // set rotation of the shape to 0\n      rotation: 0,\n      // set the 'x' position of the shape to 5 and y to -4, which puts the shape in the center of the grid, above the top\n      x: 5,\n      y: -4,\n      // set the index of the next shape to a new random shape\n      nextShape: randomShape(),\n      // Tell the game that it's currently running\n      isRunning: true,\n      // Set the score to 0\n      score: 0,\n      // Set the default speed\n      speed: 1000,\n      // Game isn't over yet\n      gameOver: false\n    }\n  }\n  // Adds current shape to grid\nexport const addBlockToGrid = (shape, grid, x, y, rotation) => {\n  // At this point the game is not over\n  let blockOffGrid = false\n  const block = shapes[shape][rotation]\n  const newGrid = [ ...grid ]\n  for (let row = 0; row < block.length; row++) {\n    for (let col = 0; col < block[row].length; col++) {\n      if (block[row][col]) {\n        const yIndex = row + y\n        // If the yIndex is less than 0 part of the block\n        // is off the top of the screen and the game is over\n        if (yIndex < 0) {\n          blockOffGrid = true\n        } else {\n          newGrid[row + y][col + x] = shape\n        }\n      }\n    }\n  }\n  // Return both the newGrid and the gameOver bool                                                \n  return { grid: newGrid, gameOver: blockOffGrid }\n}\n// Checks for completed rows and scores points\nexport const checkRows = (grid) => {\n  // Points increase for each row completed\n  // i.e. 40 points for completing one row, 100 points for two rows\n  const points = [0, 40, 100, 300, 1200]\n  let completedRows = 0\n  for (let row = 0; row < grid.length; row++) {\n    // No empty cells means it can't find a 0, so the row must be complete!\n    if (grid[row].indexOf(0) === -1) {\n      completedRows += 1\n      // Remove the row and add a new empty one at the top\n      grid.splice(row, 1)\n      grid.unshift(Array(10).fill(0))\n    }\n  }\n  return points[completedRows]\n}\n","import {\n    MOVE_RIGHT, MOVE_LEFT, MOVE_DOWN, ROTATE,\n    PAUSE, RESUME, RESTART, GAME_OVER\n  } from '../actions'\n\nimport {\n  defaultState,\n  nextRotation,\n  canMoveTo,\n  addBlockToGrid,\n  checkRows,\n  // randomShape\n} from '../utils'\n  \nconst gameReducer = (state = defaultState(), action) => {\n  const { shape, grid, x, y, rotation, nextShape, score, isRunning } = state\n  \n    switch(action.type) {\n      case ROTATE:\n        const newRotation = nextRotation(shape, rotation)\n        if (canMoveTo(shape, grid, x, y, newRotation)) {\n            return { ...state, rotation: newRotation }\n        }\n        return state\n  \n      case MOVE_RIGHT:\n        if (canMoveTo(shape, grid, x + 1, y, rotation)) {\n          return { ...state, x: x + 1 }\n        }\n        return state\n  \n      case MOVE_LEFT:\n        // subtract 1 from the x and check if this new position is possible by calling `canMoveTo()\n        if (canMoveTo(shape, grid, x - 1, y, rotation)) {\n            return { ...state, x: x - 1 }\n        }\n        return state\n  \n      case MOVE_DOWN:\n        // Get the next potential Y position\n        const maybeY = y + 1\n          \n        // Check if the current block can move here\n        if (canMoveTo(shape, grid, x, maybeY, rotation)) {\n            // If so move down don't place the block\n            return { ...state, y: maybeY }\n        }\n          \n        // If not place the block\n        // (this returns an object with a grid and gameover bool)\n        const obj = addBlockToGrid(shape, grid, x, y, rotation)\n        const newGrid = obj.grid\n        const gameOver = obj.gameOver\n          \n        if (gameOver) {\n          // Game Over\n          const newState = { ...state }\n          newState.shape = 0\n          newState.grid = newGrid\n          return { ...state, gameOver: true }\n        }\n          \n        // reset somethings to start a new shape/block\n        const newState = defaultState()\n        newState.grid = newGrid\n        newState.shape = nextShape\n        newState.score = score\n        newState.isRunning = isRunning\n                    \n        // TODO: Check and Set level\n        // Score increases decrease interval\n        newState.score = score + checkRows(newGrid)\n          \n        return newState\n          \n  \n      case RESUME:\n        return { ...state, isRunning: true }\n        \n      case PAUSE:\n        \n        return { ...state, isRunning: false }\n      \n      case GAME_OVER:\n  \n        return state\n  \n      case RESTART:\n        return defaultState()\n  \n      default:\n        return state\n    }\n  }\n  \n\nexport default gameReducer","import { combineReducers } from 'redux'\nimport gameReducer from './game_reducer'\n\n// The state handled by `gameReducer` will be stored with the property name `game` on the Redux store.\nconst reducers = combineReducers({\n  game: gameReducer\n})\n\nexport default reducers","import React, { Component } from 'react'\n\n// Represents a grid square with a color\n\nclass GridSquare extends Component {\n  render () {\n    const classes = `grid-square color-${this.props.color}`\n    return <div className={classes} />\n  }\n}\n\nexport default GridSquare","import React, { Component } from 'react'\nimport GridSquare from './grid-square'\nimport { connect } from 'react-redux'\nimport { moveDown } from '../actions'\n\n// Get Shapes from utils\nimport { shapes } from '../utils'\n\n// Represents a 10 x 18 grid of grid squares\nclass GridBoard extends Component {\n  constructor(props) {\n    super(props)\n\n    this.lastUpdateTime = 0 // the time of last update\n    this.progressTime = 0 // amount of time since the last update.\n  }\n\n  // generates an array of 18 rows, each containing 10 GridSquares.\n  makeGrid() {\n    // collect properties mapped to props from state.\n    const { grid, shape, rotation, x, y } = this.props\n    // get the block which is the current shape the player is controlling\n    const block = shapes[shape][rotation]\n    const blockColor = shape\n    // map rows\n    return grid.map((rowArray, row) => {\n      // map columns\n      return rowArray.map((square, col) => {\n        // Find the block x and y on the shape grid\n        // By subtracting the x and y from the col and the row we get the position of the upper left corner of the block array as if it was superimposed over the main grid\n        const blockX = col - x\n        const blockY = row - y\n        let color = square\n        // Map current falling block to grid.\n        // For any squares that fall on the grid we need to look at the block array and see if there is a 1 in this case we use the block color.\n        if (blockX >= 0 && blockX < block.length && blockY >= 0 && blockY < block.length) {\n          color = block[blockY][blockX] === 0 ? color : blockColor\n        }\n        // Generate a unique key for every block\n        const k = row * grid[0].length + col;\n        // Generate a grid square\n        return <GridSquare\n                key={k}\n                square={square}\n                color={color}>{square}\n              </GridSquare>\n      })\n    })\n  }\n\n  // Handle game updates\n  update(time) {\n    // If the game is is running we want to request a callback at the next animation frame.\n    window.requestAnimationFrame(this.update.bind(this))\n    if (!this.props.isRunning) {\n      return\n    }\n\n    // If lastUpdateTime not been set, set it to the current time.\n    if (!this.lastUpdateTime) {\n      this.lastUpdateTime = time\n    }\n\n    // Calculate delta time and progress time\n    const deltaTime = time - this.lastUpdateTime\n    this.progressTime += deltaTime\n\n    // If the progress time is greater than speed move the block down\n    if (this.progressTime > this.props.speed) {\n      this.props.moveDown()\n      this.progressTime = 0\n    }\n\n    // set the last update time.\n    this.lastUpdateTime = time\n  }\n\n  // requestAnimationFrame() takes a callback and only calls it once. \n  // So you need to make the first call to requestAnimationFrame() in componentDidMount().\n  componentDidMount() {\n    window.requestAnimationFrame(this.update.bind(this))\n  }\n\n  // The components generated in makeGrid are rendered in div.grid-board\n  render () {\n    return (\n      <div className='grid-board'>\n        {this.makeGrid()}\n      </div>\n    )\n  }\n}\n\nconst mapStateToProps = (state) => {\n  return {\n    grid: state.game.grid,\n    shape: state.game.shape,\n    rotation: state.game.rotation,\n    x: state.game.x,\n    y: state.game.y,\n    speed: state.game.speed,\n    isRunning: state.game.isRunning\n  }\n}\n\n// Map Dipatch to Props\nconst mapDispatchToProps = () => {\n  return {\n    moveDown\n  }\n}\n\n// Connect the component to redux\nexport default connect(mapStateToProps, mapDispatchToProps())(GridBoard)\n// export default GridBoard","import React, { Component } from 'react'\nimport GridSquare from './grid-square'\nimport { connect } from 'react-redux'\nimport { shapes } from '../utils'\n\n\n// Draws the \"next\" block view showing the next block to drop\nclass NextBlock extends Component {\n\n  makeGrid() {\n    // deconstruct shape\n    const { shape } = this.props\n    // get the array for this shape first rotation\n    const block = shapes[shape][0]\n    // get the empty shape\n    const box = shapes[0][0]        \n  \n    // Map the block to the grid\n    return box.map((rowArray, row) => {\n      return rowArray.map((square, col) => {\n        // If there is a 1 use the shape index\n        const color = block[row][col] === 0 ? 0 : shape\n        return <GridSquare key={`${row}${col}`} color={color} />\n      })\n    })\n  }\n\n  render () {\n    return (\n      <div className=\"next-block\">\n        {this.makeGrid()}\n      </div>\n    )\n  }\n}\n\n// Map State to props\n  const mapStateToProps = (state) => {\n    return {\n      // Return nextShape as shape\n      shape: state.game.nextShape\n    }\n  }\n\n  \nexport default connect(mapStateToProps)(NextBlock)\n                             ","import React, { Component } from 'react'\nimport { connect } from 'react-redux'\n\nimport { pause, resume, restart } from '../actions'\n\nclass ScoreBoard extends Component {\n\n  render() {\n    const { isRunning, score, resume, pause, restart, gameOver } = this.props\n\n    return (\n      <div className=\"score-board\">\n        <div>Score:{ score }</div>\n        <div>Level: 1</div>\n\n        <button className=\"score-board-button\" onClick={(e) => {\n          if (gameOver) { return }\n          isRunning ? pause() : resume()\n        }}>{isRunning ? \"Pause\" : \"Resume\"}</button>\n\n        <button className=\"score-board-button\" onClick={(e) => {\n          restart()\n        }}>Restart</button>\n\n      </div>\n    )\n  }\n}\n\nconst mapStateToProps = (state) => {\n  return {\n    score: state.game.score,\n    isRunning: state.game.isRunning,\n    gameOver: state.game.gameOver\n  }\n}\n\nconst mapDispatchToProps = () => {\n  return {\n    pause,\n    resume,\n    restart\n  }\n}\n\nexport default connect(mapStateToProps, mapDispatchToProps())(ScoreBoard)","import React, { Component } from 'react'\nimport { connect } from 'react-redux'\nimport { moveDown, moveLeft, moveRight, rotate } from '../actions'\n\nclass Controls extends Component {\n\n  render() {\n    const { isRunning, gameOver } = this.props\n\n    return (\n    <div className=\"controls\">\n    {/* left */}\n    <button className=\"control-button\" onClick={(e) => {\n        console.log(isRunning, gameOver)\n        if (!isRunning || gameOver) { return }\n        this.props.moveLeft()\n    }}>Left</button>\n\n    {/* right */}\n    <button className=\"control-button\" onClick={(e) => {\n        if (!isRunning || gameOver) { return }\n        this.props.moveRight()\n    }}>Right</button>\n\n    {/* rotate */}\n    <button className=\"control-button\" onClick={(e) => {\n        if (!isRunning || gameOver) { return }\n        this.props.rotate()\n    }}>Rotate</button>\n\n    {/* down */}\n    <button className=\"control-button\" onClick={(e) => {\n        if (!isRunning || gameOver) { return }\n        this.props.moveDown()\n    }}>Down</button>\n  </div>\n  )\n  }\n  }\n  const mapStateToProps = (state) => {\n    return {\n      isRunning: state.game.isRunning,\n      gameOver: state.game.gameOver\n    }\n  }\n  const mapDispatchToProps = () => {\n    return {\n        moveRight,\n        moveLeft,\n        moveDown,\n        rotate\n  }\n}\nexport default connect(mapStateToProps, mapDispatchToProps())(Controls)","import React, { Component } from 'react'\nimport { connect } from 'react-redux'\n\n// Displays a message\nclass MessagePopup extends Component {\n\n  render() {\n    const { gameOver, isRunning } = this.props\n    let message = ''\n    let isHidden = 'hidden'\n\n    // If the game is over, show the popup saying \"Game Over\"\n    if (gameOver) {\n      message = 'Game Over'\n      isHidden = ''\n    // If the game isn't running, it must be paused, so show the popup saying \"Paused\"\n    } else if (!isRunning) {\n      message = 'Paused'\n      isHidden = ''\n    // Default message, will still be hidden\n    } else {\n      message = '???'\n    }\n    return (\n      <div className={`message-popup ${isHidden}`}>\n        <h1>{message}</h1>\n        <p></p>\n      </div>\n    )\n  }\n}\n    const mapStateToProps = (state) => {\n      return {\n        gameOver: state.game.gameOver,\n        isRunning: state.game.isRunning\n    }\n  }\n\n    const mapDispatchToProps = () => {\n      return { }\n  }\n\nexport default connect(mapStateToProps, mapDispatchToProps())(MessagePopup)","import React, { Component } from 'react';\nimport { createStore } from 'redux'\nimport { Provider } from 'react-redux'\nimport reducers from './reducers'\n\nimport GridBoard from './components/grid-board'\nimport NextBlock from './components/next-block'\nimport ScoreBoard from './components/score-board'\nimport Controls from './components/controls'\nimport MessagePopup from './components/message-popup'\n\nimport './App.css';\n\nconst store = createStore(reducers)\n\nclass App extends Component {\n  render() {\n    return (\n    <Provider store={store}>\n      <div className=\"App\">\n        <header className=\"App-header\">\n          <h1 className=\"App-title\">Tetris Redux</h1>\n        </header>\n        <GridBoard />\n        <NextBlock />\n        <ScoreBoard />\n        <Controls />\n        <MessagePopup />\n      </div>\n      </Provider>\n  );\n}\n}\nexport default App;\n ","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById('root')\n);\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\n// serviceWorker.unregister();\n"],"sourceRoot":""}